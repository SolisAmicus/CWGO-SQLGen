## 步骤一：安装 cwgo

```shell
$ go install github.com/cloudwego/cwgo@latest
```

```shell
go: downloading github.com/cloudwego/cwgo v0.1.0
go: downloading github.com/cloudwego/hertz/cmd/hz v0.6.5
go: downloading github.com/Masterminds/sprig/v3 v3.2.3
go: downloading github.com/cloudwego/kitex v0.9.0
go: downloading github.com/cloudwego/thriftgo v0.3.6
go: downloading github.com/urfave/cli/v2 v2.23.5
go: downloading gorm.io/driver/mysql v1.5.1
go: downloading gorm.io/driver/postgres v1.4.5
go: downloading gorm.io/driver/sqlite v1.4.3
go: downloading gorm.io/driver/sqlserver v1.4.1
go: downloading gorm.io/gorm v1.25.1
go: downloading github.com/fatih/camelcase v1.0.0
go: downloading github.com/Masterminds/semver/v3 v3.2.0
go: downloading github.com/google/uuid v1.4.0
go: downloading gorm.io/datatypes v1.0.7
go: downloading gorm.io/plugin/dbresolver v1.3.0
go: downloading github.com/russross/blackfriday/v2 v2.1.0
go: downloading github.com/jackc/pgconn v1.13.0
go: downloading github.com/jackc/pgio v1.0.0
go: downloading github.com/jackc/pgproto3/v2 v2.3.1
go: downloading github.com/jackc/pgtype v1.12.0
go: downloading github.com/chenzhuoyu/base64x v0.0.0-20230717121745-296ad89f973d
go: downloading golang.org/x/arch v0.2.0
go: downloading golang.org/x/sys v0.16.0
go: downloading github.com/jackc/chunkreader/v2 v2.0.1
go: downloading github.com/jackc/pgservicefile v0.0.0-20200714003250-2b9c44734f2b
go: downloading github.com/apache/thrift v0.13.0
go: downloading github.com/dlclark/regexp2 v1.10.0
go: downloading github.com/chenzhuoyu/iasm v0.9.1
```

## 步骤二：设置数据库

本地安装了 $\text {MySQL}$ 数据库，创建了包含 `users` 表的`testdb` 的数据库。

```sql
CREATE DATABASE IF NOT EXISTS testdb;

USE testdb;

CREATE TABLE IF NOT EXISTS  users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);
```

## 步骤三：运行 cwgo model 命令

在命令行中使用 $\text {cwgo}$ 生成数据库模型和 $\text {CRUD}$ 代码。

```shell
$ cwgo model --db_type mysql --dsn "root:root@tcp(127.0.0.1:3306)/testdb?charset=utf8&parseTime=True&loc=Local" --out_dir "biz/dao/query" --out_file "gen.go"
```

```
got 3 columns from table <users>
Start generating code.
generate model file(table <users> -> {model.User}): F:\Projects\cwgo_db\biz\dao/model/users.gen.go
generate query file: F:\Projects\cwgo_db\biz\dao\query/users.gen.go
generate query file: F:\Projects\cwgo_db\biz\dao\query/gen.go
Generate code done.
```

## 步骤四：查看生成的代码

$\text {biz/dao/model/users.gen.go}$：定义 `User` 结构体，映射到 `users` 数据表。

```go
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model

const TableNameUser = "users"

// User mapped from table <users>
type User struct {
	ID    int32  `gorm:"column:id;primaryKey;autoIncrement:true" json:"id"`
	Name  string `gorm:"column:name;not null" json:"name"`
	Email string `gorm:"column:email;not null" json:"email"`
}

// TableName User's table name
func (*User) TableName() string {
	return TableNameUser
}
```

$\text {biz/dao/query/users.gen.go}$：定义 `UserQuery` 结构体，包含对 `users` 表的具体查询和操作方法。

- `newUser` 函数：初始化 `user` 结构体，设置数据库连接和模型，创建字段映射。

- `user` 结构体：封装了对 `users` 表的操作方法。

- 字段相关方法：
  - **`Table`**：设置新的表名。
  - **`As`**：设置表的别名。
  - **`WithContext`**：在特定的 `context.Context` 中执行操作。
  - **`TableName` 和 `Alias`**：获取表名和别名。
  - **`GetFieldByName`**：根据字段名获取字段表达式。
  - **`fillFieldMap`**：填充字段映射。

- `userDo` 结构体：继承自 `gen.DO`，提供了对数据库操作的封装。
  - **Create**：创建记录。
  - **Save**：保存记录。
  - **First**、**Take**、**Last**：获取第一条、任意一条、最后一条记录。
  - **Find**：查找所有符合条件的记录。
  - **FindInBatch** 和 `FindInBatches`：分批查找记录。
  - **Attrs** 和 **Assign**：设置默认属性和赋值。
  - **Joins** 和 **Preload**：联接和预加载关联记录。
  - **FirstOrInit** 和 **FirstOrCreate**：获取或初始化、获取或创建记录。
  - **FindByPage** 和 **ScanByPage**：分页查找记录。
  - **Scan**：将查询结果扫描到给定的目标。
  - **Delete**：删除记录。

$\text {biz/dao/query/gen.go}$：初始化了查询对象，并提供了各种通用的数据库操作方法。

```go
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:   db,
		User: newUser(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	User user
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:   db,
		User: q.User.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.clone(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.clone(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:   db,
		User: q.User.replaceDB(db),
	}
}

type queryCtx struct {
	User *userDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		User: q.User.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	return &QueryTx{q.clone(q.db.Begin(opts...))}
}

type QueryTx struct{ *Query }

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
```

## 步骤五：单元测试

```go
var db *gorm.DB
var userQuery user

func setup() {
	dsn := "root:root@tcp(127.0.0.1:3306)/testdb?charset=utf8&parseTime=True&loc=Local"
	var err error
	db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic("failed to connect database")
	}

	//err = db.AutoMigrate(&model.User{})
	//if err != nil {
	//	panic("failed to migrate database")
	//}
	db.Exec("USE testdb")
	db.Exec("CREATE TABLE IF NOT EXISTS users (" + "id INT AUTO_INCREMENT PRIMARY KEY, " + "name VARCHAR(100) NOT NULL, " + "email VARCHAR(100) UNIQUE NOT NULL)")
	userQuery = newUser(db)
}

func teardown() {
	db.Exec("DROP TABLE IF EXISTS users")
}
```

```go
func TestCreateUser(t *testing.T) {
	setup()
	defer teardown()

	newUser := &model.User{
		Name:  "John Doe",
		Email: "john.doe@example.com",
	}

	err := userQuery.userDo.Create(newUser)
	assert.NoError(t, err)
	assert.NotEqual(t, 1, newUser.ID)
}
```

```go
func TestGetUserByID(t *testing.T) {
	setup()
	defer teardown()

	newUser := &model.User{
		Name:  "John Doe",
		Email: "john.doe@example.com",
	}

	userQuery.userDo.Create(newUser)

	user, err := userQuery.userDo.First()
	assert.NoError(t, err)
	assert.Equal(t, newUser.Name, user.Name)
	assert.Equal(t, newUser.Email, user.Email)
}
```

```go
func TestFindUsers(t *testing.T) {
	setup()
	defer teardown()

	newUser1 := &model.User{
		Name:  "John Doe",
		Email: "john.doe@example.com",
	}
	newUser2 := &model.User{
		Name:  "Jane Doe",
		Email: "jane.doe@example.com",
	}

	userQuery.userDo.Create(newUser1)
	userQuery.userDo.Create(newUser2)

	users, err := userQuery.userDo.Find()
	assert.NoError(t, err)
	assert.Len(t, users, 2)
}
```

```go
func TestDeleteUser(t *testing.T) {
	setup()
	defer teardown()

	newUser := &model.User{
		Name:  "John Doe",
		Email: "john.doe@example.com",
	}

	userQuery.userDo.Create(newUser)

	_, err := userQuery.userDo.Delete(newUser)
	assert.NoError(t, err)

	_, err = userQuery.userDo.First()
	assert.Error(t, err)
}
```

